//Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
//You must write an algorithm with O(log n) runtime complexity.
//Example 1:
//Input: nums = [-1,0,3,5,9,12], target = 9
//Output: 4
//Explanation: 9 exists in nums and its index is 4
//Example 2:
//Input: nums = [-1,0,3,5,9,12], target = 2
//Output: -1
//Explanation: 2 does not exist in nums so return -1
object Solution {
    def search(nums: Array[Int], target: Int): Int = {
        def rs(beginPosition:Int, endPosition:Int, count:Int):Int={
            // Находим позицию равную сответствующую половине массива
            val middlePosition = beginPosition+(endPosition-beginPosition)/2
            if(nums(middlePosition) == target){
                // Повезло - наткнулись на решение
                return count+1
            } else if(beginPosition == endPosition && nums(beginPosition)!=target){
                // Начало и конец участка массива совпадают, 
                // однако по этому адресу target отсутствует
                return -1
            } else if((endPosition-beginPosition == 1) 
                            && nums(beginPosition)!=target && nums(endPosition)!=target){
                // Начало и конец участка имеют соседние адреса, 
                // однако в них нет target
                return -1
            } else if(nums(middlePosition) > target){
                // Ищем решение дальше в первой половине массива
                return rs(beginPosition,middlePosition,count+1)
            }  else if(nums(middlePosition) < target){
                // Ищем решение дальше во второй половине массива
                return rs(middlePosition+1, endPosition, count+middlePosition+1)
            } else {
                return -1
            }
        }
        rs(0, nums.size-1,0)
    }
}
